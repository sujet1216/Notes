flutter- იყინებს dart-ს და dart-ი ინ ენჯინზე მუშაობს რომელიც გვაძლევს წვდომას ოპერაციულ სისტემასთან,მაგ(ios) ან რაზეც გვაქვს გაშვებული. მაგ: imagepicker-ით მობილურით სურათის გადაღება.კამერასთან წვდომა(native device features)

Dart არის type safe ენა.მონაცემის(data) ტიპი(type) განსაზღვრავს იმას თუ რა ოპერაციების შესრულება შეგვიძლია ამ მონაცემებზე. მაგალითად თუ გვაქვს ცვლადი int x; არ შეგვიძლია x.toUpperCase(). 
მაგ: int x;  x = 'asd'; X

როგორ ხვდება dart , ვწერთ თუ არა type safe კოდს? 
ამისთვის იყენებს static type check(compile time) და runtime check(run time)ის კომბინაციას. ამას ქვია sound type system;
static type check -> არის როგორც 'local check'
runtime check -> 'additional check'
არის შემთხვევები როცა გინდა რომ dart analyzer-მა შეწყვიტოს შსესწორება(მოსმენა იმ კოდის რასაც წერ),  ამისთვის ვიყენებთ dynamic-ს.  ამ შემთხვევაში static analyzer-ი აღარ აქცევს მონაცემების ტიპს ყურადღებას და აღარ ამოწმებს. მაგრამ შემოწმება ხდება ყველა ვარიანტში runtime-ის დროს და თუ რამე შეცდომაა დარტი გაისვრის exception-ს.  

type inference:
var x = 2; ტიპის მინიჭება ხდება static analyzer-ის მიერ და არა რანთაიმზე.ამ შემთხვევაში x არის int ტიპის.   თუ არ გვინდა სტატიკური ანალაიზერის გამოყენება მაშინ dynamic x = 2; ამ შემთხვევაში დარტი ამოწმებს მონაცემის ტიპს რანთაიმზე. 
dynamic x = 2; x = 'a'; x = true; რანთაიმზე ხელახლა ანიჭებს ტიპს.რაც სტატიკურზე როცა ვიყენებთ var-ს შეუძლებელია. 

dynamic vs var:
var -არ არის ტიპი. არის უბრალოდ keyword.რაც სტატიკ დარტ ანალაიზერს ეუბნება: მიანიჭე ტიპი მონაცემის მიხედვით, და აღარ შეცვალო. 
dynamic -არის ტიპი. როცა ვიყენებთ დაინამიკს, სტატიკ ანალაიზერი წყვეტს შემოწმებას.შემოწმება ხდება რანთაიმზე. 
მაგრამ თუ შევქმნით: 
var x; //და არ მივანიჭებთ რაიმე მნიშვნელობას ეს იგივეა რომ დავწეროთ dynamic x;

ცვლადი (მნიშვნელობა) ვერ იქნება null ,თუ ამას ჩვენ არ ვეტყვით რო იყოს null. (sound null safety). Data(მონაცემები) შეიძლება იყოს ან მხოლოდ nullable ან არა nullable. ორივე ერთდროულად ვერ იქნება.

როგორ გადაყავს დარტს კოდი მანქანისთვის გასაგებ ენად/ გამოსაყენებელ პროგრამად ყველა პლატფორმისთვის?
დარტი იყენებს კომპაილერს რომელსაც გადაყავს source კოდი მანქანურ ენაში ან კონკრეტულ შუამავალ კოდში რომელიც ეშვება სხვადასხვა პლატფორმებზე.
arm32, arm64, x86_64 > (mobile, pc) -> ამისთვის იყენებს JIT(just in time) და AOT(ahead of time) კომპაილერს.
web -> სთვის იყენებს dartdev-dart developer compalier და dart2js კომპაილერს.

გვაქვს 2 ფაზა:  development phase and production phase;
development phase-ში გვჭირდება ადვილად გასატესტი კოდი, მარტივად რომ ვიპოვოთ ბაგები. ამდროს ვიყენებთ jit კომპაილერს. ის აკომპილირებს მხოლოდ იმ კოდს რაც ჭირდება და როცა ჭირდება და არა მთლიან კოდს. როცა აპლიკაციას ხელახლა ვუშვებთ აკომპილირებს მხოლოდიმ კოდს რაც ახლად დაემატა და არა მთლიანად თუ არაფერი შეცვლილა.jit-ის დახმარებით ხდება hot-reload;
jit-ს არ გადაყავს დარტ კოდი მანქანურ კოდში. გადაყავს მხოლოდ შუამავალ ენაში რომელსაც უშვებს დარტ ვირტუალ მაშინი. (რომ გაგვიმარტივდეს/სწრაფად მოხდეს დეველოპმენტი). და როცა რაიმე ცვლადს შევცვლით არ გვინდა რომ მთლიანი კოდის რეკომპილირება მოხდეს.
ხოლო რაც შეეხება production phase-ს: ამ შემთხვევაში არ გვაინტერესებს jit-ის რაღაცეები, hot-reload ან სხვა... რაც გვჭირდება არის ის რომ აპლიკაცია დაიწყოს და გაეშვას რაც შეიძლება სწრაფად დევაისში. ამისთვის გვჭირდება/გვინდა რომ სოურს კოდი გადავიყვანოთ native machine კოდში რომელიმე კონკრეტული პლატფორმისთვის. ამას აკეთებს aot კომპაილერი. მთლიანი სორს კოდი გადაყავს  მანქანურ კოდში სპეციფიური პლატფორმისთვის. ამას აკეთებს სანამ პლატფორმაზ გაუშვებს ამ პროგრამას.


Dart SDK:
SDK(SOFTWARE DEVELOPMENT KIT) - არის software development tools კოლექცია .ეს თულები შეიცავს: compilers, analyzers, debuggers, libraries.
dart sdk-ის დაყენებით შეგვიძლია შევქმანთ command line აპლიკაციები, სერვერ აპლიკაციები, არა ფლატერ ვებ აპლიკაციები. თუ ფლატერ აპლიკაციას ვქმნით ამიშთვის დარტ სდკ არ არის საკმარისი ამისთვის გვჭირდება ფლატერ სდკ-ც. 
თუ ფლატერ სდკ-ს დავაყენებთ ეს ავტომატურად შეიცავს/აყენებს დარტის სდკ-საც;


Dart command line interface:

cmd -> dart 
... available commands: analyze, pub, run ..... (dart sdk-ის tool-ების ჩამონათვალი)

HOW TO CREATE DART PROJECT? 

dart create -t console-full console-full-project
dart run 
ან 
cmd + shif + p  -> dart: new project 

void main(List<String> arguments) {
	print('Hello world: ${console_full_project.calculate()}!');
	print('arguments: $arguments');
}

dart run console_full_project 123 

// print('Hello world: ${console_full_project.calculate()}!');
print('arguments: $arguments'); // 123

bin folder  - CMD apps(dart run).

Dart 'project' ასეთი რამ არ არსებობს ,არის dart package.
dart package არის მთავარი კომპონენტი დარტის ეკოსისტემაში.
pub.dev ზე არის package-ბი ,სხვა დეველოპერებისგან შექმნილი რომელიც გვეხმარება რომ ავირიდოთ ყველაფრის თავიდან ხელახლა წერა(კოდის), არის გამზადებული კოდი.

application package - რომელიც არ არის,არ ვტვირთავთ pub.devზე 
library package - რომელსაც ვტვირთავთ,არის pub.dev-ze

ასე რომ ჩვენი პროექტი არის package,რომელიც იყენებს/დამოკიდებულია სხვა package-ბზე.

პაკიჯების მენეჯერი არის -> pub .     dart pub add ....

libraries - არის მხოლოდ ის ნაწილი, რომელიც ხელმისაწვდომია ყველასთვის. package-ში შეიძლება იყოს რამდენიმე ლაიბრარი. 

Dart VM(virtual machine):














